import { Pool } from "pg";
import { createTasksTable } from "../queries";
import { AbstractHandlerManager } from "./abstractHandlerManager";
import { TaskManagerOptions, TaskQueryOptions, TaskType } from "../types";
import { logger } from "../logger";
import {mustBeInitialized} from "../util";
import {Base} from "../standAlone/base";

const log = logger(__filename);

export const Errors = {
  INVALID_DATE: "Date must be in the future",
  TASK_INSERT_ERROR: "Error inserting task",
  NO_QUERY_FILTERS: "No query filters provided",
  NO_REGISTERED_HANDLER: (name: string) => `No handler registered for ${name}`,
};

export abstract class AbstractTaskManager extends Base {
  protected readonly clearOutdatedTasks: boolean;
  protected readonly maxTaskAge: number;

  protected pool: Pool;

  protected constructor(options: TaskManagerOptions) {
    super({ namespace: options.namespace });
    this.pool = options.pool;
    this.clearOutdatedTasks = options.clearOutdatedTasks ?? true;
    this.maxTaskAge = options.maxTaskAge ?? 86400000;
    log.debug(
      "Created new task manager with\n" +
        `\tautoClearOldTasks:${String(this.clearOutdatedTasks)}\n` +
        `\tmaxTaskAge: ${this.maxTaskAge}`,
    );
  }

  public async init() {
    if (this.initialized) {
      return;
    }

    await this.pool.query(createTasksTable);

    if (this.clearOutdatedTasks) {
      await this.clearOldTasks();
    }
    this.initialized = true;
  }

  // TODO: should jobs added from a centralized manager have a flag to indicate that they are not to be executed by
  //  the distributed manager? In other words, how does the centralized manager interact with the distributed manager?
  /**
   * Schedule a task to be executed at the given date. This function throws if the date is not at least 1 minute
   * in the future or if the insertion query fails.
   * @param date
   * @param name
   * @param data
   * @param category
   * @param handlerManager
   * @returns {Promise<number>} The integer id of the task inserted into the database.
   */
  public async scheduleTask({
    date,
    name,
    data,
    namespace,
    handlerManager,
  }: {
    date: Date;
    name: string;
    data: string;
    namespace: string;
    handlerManager: AbstractHandlerManager;
  }): Promise<number> {
    mustBeInitialized(this.initialized, this.constructor.name);

    if (date.getTime() <= Date.now()) {
      throw new Error(Errors.INVALID_DATE);
    }

    // TODO: this method will need to be overriden for the distributed
    //  scheduler to handle the case where the task is scheduled for another scheduler
    const taskHandlers = handlerManager.getTaskHandlers();
    if (!taskHandlers[name]) {
      throw new Error(Errors.NO_REGISTERED_HANDLER(name));
    }

    // insert the task into the database
    const res = await this.pool.query(
      `
          INSERT INTO tasks (date, name, data, namespace)
          VALUES ($1, $2, $3, $4) RETURNING id;
      `,
      [date, name, data, namespace],
    );
    log.debug(
      `Inserted task '${name}' into database. Resulting rows:`,
      JSON.stringify(res.rows, null, 2),
    );

    // return the integer task id generated by the database
    if (res.rows.length === 1) {
      return res.rows[0].id as number;
    } else {
      throw new Error(Errors.TASK_INSERT_ERROR);
    }
  }

  public async removeTasks(options: TaskQueryOptions) {
    mustBeInitialized(this.initialized, this.constructor.name);
    const filters = this.buildTaskFilterQuery(options);
    const result = await this.pool.query(
      `
          DELETE
          FROM tasks
          WHERE ${filters.filterString};
      `,
      filters.values,
    );

    return result.rowCount;
  }

  /**
   * Get all tasks with the given options.
   * @param options An options object that can contain an id, name, or category.
   */
  public async getTasks(options?: TaskQueryOptions): Promise<TaskType[]> {
    mustBeInitialized(this.initialized, this.constructor.name);
    if (!options) {
      const { rows } = await this.pool.query(`
          SELECT *
          FROM tasks
          WHERE namespace = $1;
      `, [this._namespace]);
      return rows as TaskType[];
    } else {
      const filters = this.buildTaskFilterQuery(options);
      const result = await this.pool.query(
        `
            SELECT *
            FROM tasks
            WHERE ${filters.filterString} AND namespace = $${filters.values.length + 1}
        `,
        [...filters.values, this._namespace],
      );

      return result.rows as TaskType[];
    }
  }

  /**
   * Gets all tasks that are ready to be executed. This means tasks returned by this function are not locked in the
   * database by another scheduler.
   * @param handlerNames
   * @protected
   */
  protected abstract getExecutableTasks(
    handlerNames?: string[],
  ): Promise<TaskType[]>;

  // Used to clean up tasks that were never picked up by a task handler.
  // This will only occur if a tasks execution time passes while there is no registered task handler.
  // By default, this will execute automatically when the scheduler is instantiated.
  public async clearOldTasks() {
    try {
      const result = await this.pool.query(
        `
      WITH task_ids AS MATERIALIZED (
        SELECT id
        FROM tasks
        WHERE
            namespace = $1 AND
            date <= (CURRENT_TIMESTAMP - ($2 * INTERVAL '1 millisecond'))
        FOR UPDATE SKIP LOCKED
      ) DELETE FROM tasks
      WHERE id IN (SELECT id FROM task_ids);
    `,
        [this._namespace, this.maxTaskAge],
      );
      log.debug(
        `Cleared ${result.rowCount} tasks that were older than ${this.maxTaskAge} ms`,
      );
    } catch (e) {
      log.error(`Failed to clear old tasks`, e);
    }
  }

  private buildTaskFilterQuery(options: TaskQueryOptions): {
    filterString: string;
    values: (string | number | number[])[];
  } {
    const filters: string[] = [];
    const filterValues: (string | number | number[])[] = [];
    if (options.id) {
      filters.push("id = $1");
      filterValues.push(String(options.id));
    } else if (options.name) {
      filters.push(`name = $${filters.length + 1}}`);
      filterValues.push(options.name);
    } else if (options.namespace) {
      filters.push(`category = $${filters.length + 1}}`);
      filterValues.push(options.namespace);
    } else if (options.notIds && options.notIds.length > 0) {
      filters.push(`id NOT IN ($${filters.length + 1})`);
      filterValues.push(options.notIds);
    }

    if (filters.length === 0) {
      throw new Error(Errors.NO_QUERY_FILTERS);
    }

    return { filterString: filters.join(" AND "), values: filterValues };
  }
}
