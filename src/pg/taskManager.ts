import { CheckInitialized } from "../util";
import { Client } from "pg";
import { TaskQueryOptions } from "./types";
import {createTasksTable} from "./queries";

export type TaskManagerOptions = {
  autoClearOldTasks?: boolean;
}

export class TaskManager {
  private readonly autoClearOldTasks: boolean;
  private client: Client;
  private initialized: boolean = false;

  constructor(options: TaskManagerOptions) {
    this.autoClearOldTasks = options.autoClearOldTasks || true;
  }

  public async init(client: Client) {
    this.client = client;
    await this.client.query(createTasksTable);

    if (this.autoClearOldTasks) {
      await this.clearOldTasks();
    }
    this.initialized = true;
  }

  // TODO: should jobs added from a centralized manager have a flag to indicate that they are not to be executed by
  //  the distributed manager? In other words, how does the centralized manager interact with the distributed manager?
  /**
   * Schedule a task to be executed at the given date. This function throws if the date is not at least 1 minute
   * in the future or if the insertion query fails.
   * @param date
   * @param name
   * @param data
   * @param category
   * @returns {Promise<number>} The integer id of the task inserted into the database.
   */
  @CheckInitialized
  public async scheduleTask(
    date: Date,
    name: string,
    data: string,
    category: string | null = null
  ): Promise<number> {
    // ensure date is at least 1 minute in the future
    // TODO: adjust this and see if immediate time is viable
    if (date <= Date.now() + 60000) {
      throw new Error("Date must be in the future");
    }

    // insert the task into the database
    const res = await this.client.query(
      `
      INSERT INTO tasks (date, name, data, category)
      VALUES ($1, $2, $3, $4)
      RETURNING id;
    `,
      [date, name, data, category]
    );

    // return the integer task id generated by the database
    if (res.rows.length !== 1) {
      return res.rows[0].id;
    } else {
      throw new Error("Error inserting task");
    }
  }

  @CheckInitialized
  public async removeTasks(options: TaskQueryOptions) {
    const filters= this.buildTaskFilterQuery(options);
    const result = await this.client.query(`
      DELETE FROM tasks
      WHERE ${filters.filterString};
    `, filters.values);

    return result.rowCount;
  }

  /**
   * Get all tasks with the given options.
   * @param options An options object that can contain an id, name, or category.
   */
  @CheckInitialized
  public async getTasks(options: TaskQueryOptions) {
    const filters = this.buildTaskFilterQuery(options);
    const result = await this.client.query(`
      SELECT * FROM tasks
      WHERE ${filters.filterString};
    `, filters.values);

    return result.rows;
  }

  // Used to clean up tasks that were never picked up by a task handler.
  // This will only occur if a tasks execution time passes while there is no registered task handler.
  // By default, this will execute automatically when the scheduler is instantiated.
  @CheckInitialized
  public async clearOldTasks() {}

  private buildTaskFilterQuery(options: TaskQueryOptions): { filterString: string, values: string[] } {
    const filters: string[] = [];
    const filterValues: string[] = [];
    if (options.id) {
      filters.push("id = $1");
      filterValues.push(String(options.id));
    } else if (options.name) {
      filters.push(`name = $${filters.length + 1}}`);
      filterValues.push(options.name);
    } else if (options.category) {
      filters.push(`category = $${filters.length + 1}}`);
      filterValues.push(options.category);
    }

    if (filters.length === 0) {
      throw new Error("No options provided");
    }

    return { filterString: filters.join(" AND "), values: filterValues };
  }
}
