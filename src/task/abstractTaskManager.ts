import { CheckInitialized } from "../util";
import { Client } from "pg";
import { createTasksTable } from "../queries";
import { TaskManagerOptions, TaskQueryOptions, TaskType } from "./types";
import { AbstractHandlerManager } from "../handler/types";

export abstract class AbstractTaskManager {
  protected readonly autoClearOldTasks: boolean;
  protected readonly maxTaskAge: number;

  protected client: Client;
  protected initialized = false;

  protected constructor(options: TaskManagerOptions) {
    this.client = options.client;
    this.autoClearOldTasks = options.autoClearOldTasks || true;
    this.maxTaskAge = options.maxTaskAge || 86400000;
  }

  public async init() {
    await this.client.query(createTasksTable);

    if (this.autoClearOldTasks) {
      await this.clearOldTasks();
    }
    this.initialized = true;
  }

  // TODO: should jobs added from a centralized manager have a flag to indicate that they are not to be executed by
  //  the distributed manager? In other words, how does the centralized manager interact with the distributed manager?
  /**
   * Schedule a task to be executed at the given date. This function throws if the date is not at least 1 minute
   * in the future or if the insertion query fails.
   * @param date
   * @param name
   * @param data
   * @param category
   * @param handlerManager
   * @returns {Promise<number>} The integer id of the task inserted into the database.
   */
  @CheckInitialized
  public async scheduleTask(
    date: Date,
    name: string,
    data: string,
    category: string | null = null,
    handlerManager: AbstractHandlerManager
  ): Promise<number> {
    // ensure date is at least 1 minute in the future
    // TODO: adjust this and see if immediate time is viable
    if (date.getTime() <= Date.now() + 60000) {
      throw new Error("Date must be in the future");
    }

    // TODO: only allows tasks to be scheduled for handlers that are registered with the handler manager
    //  should expand so that tasks can be scheduled for handlers that are not registered with the handler manager
    //  when using the distributed manager
    const taskHandlers = handlerManager.getTaskHandlers();
    if (!taskHandlers[name]) {
      throw new Error(`No task handler registered for ${name}`);
    }

    // insert the task into the database
    const res = await this.client.query(
      `
      INSERT INTO tasks (date, name, data, category)
      VALUES ($1, $2, $3, $4)
      RETURNING id;
    `,
      [date, name, data, category]
    );

    // return the integer task id generated by the database
    if (res.rows.length !== 1) {
      return res.rows[0].id as number;
    } else {
      throw new Error("Error inserting task");
    }
  }

  @CheckInitialized
  public async removeTasks(options: TaskQueryOptions) {
    const filters = this.buildTaskFilterQuery(options);
    const result = await this.client.query(
      `
      DELETE FROM tasks
      WHERE ${filters.filterString};
    `,
      filters.values
    );

    return result.rowCount;
  }

  /**
   * Get all tasks with the given options.
   * @param options An options object that can contain an id, name, or category.
   */
  @CheckInitialized
  public async getTasks(options?: TaskQueryOptions): Promise<TaskType[]> {
    if (!options) {
      const { rows } = await this.client.query(`
        SELECT * FROM tasks;
      `);
      return rows as TaskType[];
    } else {
      const filters = this.buildTaskFilterQuery(options);
      const result = await this.client.query(
        `
      SELECT * FROM tasks
      WHERE ${filters.filterString};
    `,
        filters.values
      );

      return result.rows as TaskType[];
    }
  }

  /**
   * Gets all tasks that are ready to be executed. This means tasks returned by this function are not locked in the
   * database by another
   * @param handlerNames
   * @protected
   */
  protected abstract getExecutableTasks(
    handlerNames?: string[]
  ): Promise<TaskType[]>;

  // Used to clean up tasks that were never picked up by a task handler.
  // This will only occur if a tasks execution time passes while there is no registered task handler.
  // By default, this will execute automatically when the scheduler is instantiated.
  @CheckInitialized
  public async clearOldTasks() {}

  private buildTaskFilterQuery(options: TaskQueryOptions): {
    filterString: string;
    values: any[];
  } {
    const filters: string[] = [];
    const filterValues: any[] = [];
    if (options.id) {
      filters.push("id = $1");
      filterValues.push(String(options.id));
    } else if (options.name) {
      filters.push(`name = $${filters.length + 1}}`);
      filterValues.push(options.name);
    } else if (options.category) {
      filters.push(`category = $${filters.length + 1}}`);
      filterValues.push(options.category);
    } else if (options.notIds && options.notIds.length > 0) {
      filters.push(`id NOT IN ($${filters.length + 1})`);
      filterValues.push(options.notIds);
    }

    if (filters.length === 0) {
      throw new Error("No options provided");
    }

    return { filterString: filters.join(" AND "), values: filterValues };
  }
}
